<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GLB Loading Test</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: Arial, sans-serif;
            background: #1a1a1a;
            color: #fff;
        }
        #container {
            width: 100%;
            height: 80vh;
            border: 2px solid #444;
            margin: 20px 0;
        }
        .info {
            background: #2a2a2a;
            padding: 15px;
            border-radius: 5px;
            margin: 10px 0;
        }
        .success { color: #4CAF50; }
        .error { color: #f44336; }
        .warning { color: #ff9800; }
        button {
            padding: 10px 20px;
            margin: 5px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }
        button:hover { background: #45a049; }
        button:disabled { background: #666; cursor: not-allowed; }
        #log {
            background: #000;
            padding: 10px;
            border-radius: 5px;
            max-height: 200px;
            overflow-y: auto;
            font-family: monospace;
            font-size: 12px;
        }
    </style>
</head>
<body>
    <h1>ðŸ§ª GLB Loading Test</h1>
    <p>This test verifies that GLB files can be loaded from the assets folder and displayed in the scene.</p>
    
    <div class="info">
        <strong>Test Files:</strong>
        <ul>
            <li>person_0.glb (should load at position -2, 0, 0)</li>
            <li>person_1.glb (should load at position 2, 0, 0)</li>
        </ul>
    </div>
    
    <button id="test-local">Test Local Assets</button>
    <button id="test-cdn">Test CDN GLB (Fallback)</button>
    <button id="clear-scene">Clear Scene</button>
    
    <div id="container"></div>
    
    <div class="info">
        <strong>Test Results:</strong>
        <div id="results"></div>
    </div>
    
    <div class="info">
        <strong>Console Log:</strong>
        <div id="log"></div>
    </div>

    <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
        "three/examples/jsm/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
      }
    }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';
        
        // Setup scene
        const container = document.getElementById('container');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x101010);
        
        const camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
        camera.position.set(0, 2, 5);
        camera.lookAt(0, 0, 0);
        
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(container.clientWidth, container.clientHeight);
        renderer.shadowMap.enabled = true;
        container.appendChild(renderer.domElement);
        
        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(5, 10, 5);
        directionalLight.castShadow = true;
        scene.add(directionalLight);
        
        // Ground
        const groundGeometry = new THREE.PlaneGeometry(20, 20);
        const groundMaterial = new THREE.MeshStandardMaterial({ color: 0x6b6b6b });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        scene.add(ground);
        
        // Grid helper
        const gridHelper = new THREE.GridHelper(20, 20, 0x444444, 0x222222);
        scene.add(gridHelper);
        
        const loader = new GLTFLoader();
        const resultsDiv = document.getElementById('results');
        const logDiv = document.getElementById('log');
        let loadedModels = [];
        
        function log(message, type = 'info') {
            const timestamp = new Date().toLocaleTimeString();
            const color = type === 'error' ? '#f44336' : type === 'success' ? '#4CAF50' : type === 'warning' ? '#ff9800' : '#fff';
            logDiv.innerHTML += `<div style="color: ${color}">[${timestamp}] ${message}</div>`;
            logDiv.scrollTop = logDiv.scrollHeight;
            console.log(message);
        }
        
        function updateResults() {
            resultsDiv.innerHTML = `
                <p class="${loadedModels.length === 2 ? 'success' : 'warning'}">
                    Loaded ${loadedModels.length} of 2 models
                </p>
                <ul>
                    ${loadedModels.map(m => `<li class="success">âœ“ ${m.name} at (${m.position.x}, ${m.position.y}, ${m.position.z})</li>`).join('')}
                </ul>
            `;
        }
        
        async function loadGLB(url, name, position) {
            return new Promise((resolve, reject) => {
                log(`Attempting to load ${name} from ${url}...`);
                loader.load(
                    url,
                    (gltf) => {
                        const model = gltf.scene;
                        model.position.copy(position);
                        model.name = name;
                        
                        // Enable shadows
                        model.traverse((child) => {
                            if (child instanceof THREE.Mesh) {
                                child.castShadow = true;
                                child.receiveShadow = true;
                            }
                        });
                        
                        scene.add(model);
                        loadedModels.push({ name, position: position.clone() });
                        log(`âœ“ Successfully loaded ${name}`, 'success');
                        updateResults();
                        resolve(model);
                    },
                    (progress) => {
                        if (progress.total > 0) {
                            const percent = (progress.loaded / progress.total * 100).toFixed(1);
                            log(`Loading ${name}: ${percent}%`);
                        }
                    },
                    (error) => {
                        log(`âœ— Failed to load ${name}: ${error.message}`, 'error');
                        reject(error);
                    }
                );
            });
        }
        
        async function testLocalAssets() {
            log('=== Testing Local Assets ===', 'info');
            loadedModels = [];
            scene.children.filter(c => c.name && (c.name.includes('person') || c.name.includes('test'))).forEach(c => scene.remove(c));
            updateResults();
            
            const personFiles = ['person_0.glb', 'person_1.glb'];
            const positions = [
                new THREE.Vector3(-2, 0, 0),
                new THREE.Vector3(2, 0, 0)
            ];
            
            const pathVariations = [
                './dist/assets/',
                'dist/assets/',
                '/dist/assets/',
                './assets/',
                'assets/',
                '../assets/'
            ];
            
            for (let i = 0; i < personFiles.length; i++) {
                const filename = personFiles[i];
                const position = positions[i];
                let loaded = false;
                
                for (const basePath of pathVariations) {
                    const fullPath = basePath + filename;
                    try {
                        // Test if file exists
                        const response = await fetch(fullPath, { method: 'HEAD' });
                        if (response.ok) {
                            await loadGLB(fullPath, filename, position);
                            loaded = true;
                            break;
                        }
                    } catch (err) {
                        continue;
                    }
                }
                
                if (!loaded) {
                    log(`âœ— Could not find ${filename} in any path variation`, 'error');
                }
            }
        }
        
        async function testCDN() {
            log('=== Testing CDN GLB (Fallback) ===', 'info');
            loadedModels = [];
            scene.children.filter(c => c.name && (c.name.includes('person') || c.name.includes('test'))).forEach(c => scene.remove(c));
            updateResults();
            
            // Test with a known working GLB from CDN
            const testUrl = 'https://raw.githubusercontent.com/KhronosGroup/glTF-Sample-Models/master/2.0/Duck/glTF-Binary/Duck.glb';
            try {
                await loadGLB(testUrl, 'Duck (CDN Test)', new THREE.Vector3(0, 0, 0));
                log('âœ“ CDN loading works! Your GLB files should work too if paths are correct.', 'success');
            } catch (err) {
                log(`âœ— CDN test failed: ${err.message}`, 'error');
            }
        }
        
        function clearScene() {
            log('Clearing scene...', 'info');
            loadedModels = [];
            scene.children.filter(c => c.name && (c.name.includes('person') || c.name.includes('test') || c.name.includes('Duck'))).forEach(c => scene.remove(c));
            updateResults();
        }
        
        document.getElementById('test-local').addEventListener('click', testLocalAssets);
        document.getElementById('test-cdn').addEventListener('click', testCDN);
        document.getElementById('clear-scene').addEventListener('click', clearScene);
        
        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }
        animate();
        
        // Handle resize
        window.addEventListener('resize', () => {
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        });
        
        log('GLB Loading Test initialized. Click "Test Local Assets" to begin.', 'info');
    </script>
</body>
</html>
